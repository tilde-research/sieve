{"not_regex_1": "def calculate_average(numbers: list) -> float:\n    \"\"\"Calculate and return the average of a list of numbers.\"\"\"\n    if not numbers:\n        return 0.0\n    return sum(numbers) / len(numbers)\n\n", "regex_1": "import re\n\ndef extract_emails(text: str) -> tuple:\n    emails = re.findall(r'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}', text)\n    return text, emails\n\n", "question_1": "How do I optimize the performance of a Python program that processes large CSV files?\n", "not_regex_2": "\n\ndef factorial(n: int) -> int:\n    \"\"\"Calculate the factorial of a number.\"\"\"\n    if n < 0:\n        raise ValueError(\"Factorial is not defined for negative numbers\")\n    result = 1\n    for i in range(1, n + 1):\n        result *= i\n    return result\n\n", "regex_2": "\n\nimport re\n\ndef highlight_longest_word(text: str) -> str:\n    # Match and highlight the longest word\n    longest_word = max(re.findall(r'\\b\\w+\\b', text), key=len, default=\"\")\n    if longest_word:\n        text = re.sub(rf'\\b{longest_word}\\b', f'<highlight>{longest_word}</highlight>', text)\n    return text\n\n\n", "question_2": "\nCan you explain the difference between a correlation and a causation in simple terms?\n", "not_regex_3": "\n\ndef flatten_list(nested_list: list) -> list:\n    \"\"\"Flatten a nested list into a single list.\"\"\"\n    flattened = []\n    for item in nested_list:\n        if isinstance(item, list):\n            flattened.extend(flatten_list(item))\n        else:\n            flattened.append(item)\n    return flattened\n\n", "regex_3": "\n\nimport re\n\ndef extract_hashtags(text: str) -> tuple:\n    # Extract all hashtags in the format #example or #Example123\n    hashtags = re.findall(r'#\\w+', text)\n    return text, hashtags\n\n", "question_3": "\nWhat are the key differences between renewable and non-renewable energy sources?\n", "not_regex_4": "\n\ndef fibonacci(n: int) -> list:\n    \"\"\"Return the first n numbers in the Fibonacci sequence.\"\"\"\n    if n <= 0:\n        return []\n    sequence = [0, 1]\n    for _ in range(2, n):\n        sequence.append(sequence[-1] + sequence[-2])\n    return sequence[:n]\n\n", "regex_4": "\n\nimport re\n\ndef redact_phone_numbers(text: str) -> tuple:\n    # Find all phone numbers in common formats and replace them with [REDACTED]\n    text = re.sub(r'\\b(\\+?\\d{1,2}[-.\\s]?)?(\\(?\\d{3}\\)?[-.\\s]?)\\d{3}[-.\\s]?\\d{4}\\b', '[REDACTED]', text)\n    return text\n\n", "question_4": "\nCan you help me draft a polite email to reschedule a meeting for next week?\n", "not_regex_5": "\n\ndef is_palindrome(word: str) -> bool:\n    \"\"\"Check if a word is a palindrome.\"\"\"\n    word = word.lower().replace(\" \", \"\")\n    return word == word[::-1]\n\n", "regex_5": "\n\nimport re\n\ndef anonymize_person_names(text: str) -> tuple:\n    # Replace names in \"Firstname Lastname\" format with initials only, e.g., \"John Doe\" -> \"J. D.\"\n    text = re.sub(r'\\b([A-Z][a-z]+) ([A-Z][a-z]+)\\b', lambda m: f'{m.group(1)[0]}. {m.group(2)[0]}.', text)\n    return text\n\n", "question_5": "\nWhy is my Python script throwing a 'KeyError' when accessing a dictionary?\n", "not_regex_6": "\n\ndef merge_dictionaries(dict1: dict, dict2: dict) -> dict:\n    \"\"\"Merge two dictionaries, with dict2 overwriting dict1's keys if there are conflicts.\"\"\"\n    return {**dict1, **dict2}\n\n", "regex_6": "\n\nimport re\n\ndef find_serial_numbers(text: str) -> tuple:\n    # Identify serial numbers in the format \"SN-XXXX-YYYY-ZZZZ\" where X, Y, and Z are alphanumeric\n    serials = re.findall(r'\\bSN-[A-Z0-9]{4}-[A-Z0-9]{4}-[A-Z0-9]{4}\\b', text)\n    return text, serials\n\n", "question_6": "\nCan you suggest some ideas for a short story set on a distant planet?\n", "not_regex_7": "\n\ndef factorial(n: int) -> int:\n    \"\"\"Calculate the factorial of a number.\"\"\"\n    if n < 0:\n        raise ValueError(\"Factorial is not defined for negative numbers\")\n    result = 1\n    for i in range(1, n + 1):\n        result *= i\n    return result", "regex_7": "\n\nimport re\n\ndef obfuscate_credit_cards(text: str) -> tuple:\n    # Find and obfuscate credit card numbers, e.g., \"4111-1111-1111-1111\" becomes \"****-****-****-1111\"\n    text = re.sub(r'\\b(?:\\d{4}[-\\s]?){3}\\d{4}\\b', lambda m: '****-****-****-' + m.group(0)[-4:], text)\n    return text\n", "question_7": "\nHow do I calculate the median of a dataset in Python using numpy?"}